# é”™è¯¯ä¿®å¤è®°å½• - 2025å¹´12æœˆ31æ—¥

æœ¬æ–‡æ¡£è®°å½•äº†çŸ¥è¯†åº“æ–‡æ¡£ä¸Šä¼ è¿‡ç¨‹ä¸­é‡åˆ°çš„æ‰€æœ‰é”™è¯¯åŠå…¶ä¿®å¤æ–¹æ¡ˆã€‚

---

## ğŸ“‹ ç›®å½•

1. [é”™è¯¯ä¸€ï¼šç§Ÿæˆ·éš”ç¦»ä¸­é—´ä»¶æ‰¹é‡åˆ›å»º Panic](#é”™è¯¯ä¸€ç§Ÿæˆ·éš”ç¦»ä¸­é—´ä»¶æ‰¹é‡åˆ›å»º-panic)
2. [é”™è¯¯äºŒï¼šå‘é‡åŒ–è¿‡ç¨‹ NaN å€¼å¯¼è‡´ JSON åºåˆ—åŒ–å¤±è´¥](#é”™è¯¯äºŒå‘é‡åŒ–è¿‡ç¨‹-nan-å€¼å¯¼è‡´-json-åºåˆ—åŒ–å¤±è´¥)
3. [é”™è¯¯ä¸‰ï¼šOllama API å“åº”åŒ…å« NaN å€¼](#é”™è¯¯ä¸‰ollama-api-å“åº”åŒ…å«-nan-å€¼)
4. [é”™è¯¯å››ï¼šåµŒå…¥ç»“æœæ•°ç»„è¶Šç•Œ](#é”™è¯¯å››åµŒå…¥ç»“æœæ•°ç»„è¶Šç•Œ)
5. [å®Œæ•´çš„é˜²æŠ¤ä½“ç³»](#å®Œæ•´çš„é˜²æŠ¤ä½“ç³»)

---

## é”™è¯¯ä¸€ï¼šç§Ÿæˆ·éš”ç¦»ä¸­é—´ä»¶æ‰¹é‡åˆ›å»º Panic

### ğŸ› é”™è¯¯ç°è±¡

```
asynq: pid=32536 2025/12/31 07:29:43.212771 ERROR: recovering from panic.
goroutine 1856 [running]:
...
reflect.Value.Field({0x7ff7ce2f7820?, 0xc000151698?, 0x1?}, 0xc000f76c00?) 
        C:/Program Files/Go/src/reflect/value.go:1261 +0xcf
gorm.io/gorm/schema.(*Field).setupValuerAndSetter.func1(...)
github.com/Tencent/WeKnora/internal/database.TenantIsolationMiddleware.func2(0xc000e3a960)
        D:/workdir/ai/code/WeKnora/internal/database/tenant_isolation.go:64 +0x125
```

### ğŸ” é—®é¢˜åˆ†æ

åœ¨ç§Ÿæˆ·éš”ç¦»ä¸­é—´ä»¶ä¸­ï¼Œå½“æ‰§è¡Œ `CreateInBatches` æ‰¹é‡åˆ›å»ºæ“ä½œæ—¶ï¼š
- `d.Statement.ReflectValue` æ˜¯ä¸€ä¸ª**åˆ‡ç‰‡ç±»å‹**è€Œéå•ä¸ªç»“æ„ä½“
- ç›´æ¥è°ƒç”¨ `field.ValueOf()` è®¿é—®å­—æ®µå¯¼è‡´ panic
- éœ€è¦åŒºåˆ†å¤„ç†å•ä¸ªåˆ›å»ºå’Œæ‰¹é‡åˆ›å»ºä¸¤ç§æƒ…å†µ

### âœ… ä¿®å¤æ–¹æ¡ˆ

**æ–‡ä»¶ï¼š** `internal/database/tenant_isolation.go`

**å…³é”®ä¿®æ”¹ï¼š**

```go
// æ·»åŠ  reflect åŒ…å¯¼å…¥
import (
    "context"
    "reflect"  // æ–°å¢
    ...
)

// ä¿®æ”¹ Create å›è°ƒ
db.Callback().Create().Before("gorm:create").Register("tenant_isolation:create", func(d *gorm.DB) {
    if skip, _ := d.InstanceGet("skip_tenant_isolation"); skip == true {
        return
    }
    if d.Statement.Schema != nil {
        if field, ok := d.Statement.Schema.FieldsByDBName["tenant_id"]; ok {
            if tenantID, ok := GetTenantID(d.Statement.Context); ok && tenantID > 0 {
                // æ£€æŸ¥ ReflectValue æ˜¯å¦æœ‰æ•ˆ
                if d.Statement.ReflectValue.IsValid() && d.Statement.ReflectValue.Kind() != 0 {
                    reflectValue := d.Statement.ReflectValue
                    
                    // åŒºåˆ†æ‰¹é‡åˆ›å»ºå’Œå•ä¸ªåˆ›å»º
                    if reflectValue.Kind() == reflect.Slice {
                        // æ‰¹é‡åˆ›å»ºï¼šéå†åˆ‡ç‰‡è®¾ç½®æ¯ä¸ªå…ƒç´ 
                        for i := 0; i < reflectValue.Len(); i++ {
                            elem := reflectValue.Index(i)
                            if elem.Kind() == reflect.Ptr {
                                elem = elem.Elem()
                            }
                            if elem.IsValid() && elem.Kind() == reflect.Struct {
                                if _, isZero := field.ValueOf(d.Statement.Context, elem); isZero {
                                    if tenantField := elem.FieldByName("TenantID"); tenantField.IsValid() && tenantField.CanSet() {
                                        tenantField.SetUint(tenantID)
                                    }
                                }
                            }
                        }
                    } else {
                        // å•ä¸ªåˆ›å»º
                        if _, isZero := field.ValueOf(d.Statement.Context, d.Statement.ReflectValue); isZero {
                            d.Statement.SetColumn("tenant_id", tenantID)
                        }
                    }
                }
            }
        }
    }
})
```

### ğŸ“Š å½±å“èŒƒå›´

- æ‰€æœ‰ä½¿ç”¨ `CreateInBatches` çš„æ‰¹é‡åˆ›å»ºæ“ä½œ
- ç‰¹åˆ«æ˜¯çŸ¥è¯†åº“æ–‡æ¡£åˆ†å—çš„æ‰¹é‡åˆ›å»º

---

## é”™è¯¯äºŒï¼šå‘é‡åŒ–è¿‡ç¨‹ NaN å€¼å¯¼è‡´ JSON åºåˆ—åŒ–å¤±è´¥

### ğŸ› é”™è¯¯ç°è±¡

```
ERROR BatchEmbedWithPool failed: failed to get embedding vectors: 
      failed to encode response: json: unsupported value: NaN
ERROR Repository postgres failed to batch save: 
      failed to get embedding vectors: failed to encode response: json: unsupported value: NaN
```

### ğŸ” é—®é¢˜åˆ†æ

åµŒå…¥æ¨¡å‹è¿”å›çš„å‘é‡ä¸­åŒ…å« NaNï¼ˆNot a Numberï¼‰æˆ– Infï¼ˆæ— ç©·å¤§ï¼‰å€¼ï¼š
- è¿™äº›å€¼æ— æ³•è¢« JSON åºåˆ—åŒ–
- åœ¨ä¿å­˜åˆ°æ•°æ®åº“æ—¶ä¼šæŠ¥é”™
- éœ€è¦åœ¨å¤šä¸ªå±‚é¢è¿›è¡Œæ¸…ç†

### âœ… ä¿®å¤æ–¹æ¡ˆ

#### æ–¹æ¡ˆ 1: Batch Embedder æ¸…ç†

**æ–‡ä»¶ï¼š** `internal/models/embedding/batch.go`

```go
import (
    "context"
    "fmt"
    "math"  // æ–°å¢
    ...
)

// sanitizeVector ç§»é™¤å‘é‡ä¸­çš„ NaN å’Œ Inf å€¼
func sanitizeVector(vec []float32) ([]float32, error) {
    hasInvalid := false
    for i, v := range vec {
        if math.IsNaN(float64(v)) || math.IsInf(float64(v), 0) {
            vec[i] = 0.0
            hasInvalid = true
        }
    }
    if hasInvalid {
        return vec, fmt.Errorf("vector contained NaN or Inf values, replaced with 0.0")
    }
    return vec, nil
}

// åœ¨æ‰¹é‡å¤„ç†æ—¶æ¸…ç†
mu.Lock()
for i, text := range texts {
    if text == nil {
        continue
    }
    // æ¸…ç†å‘é‡
    sanitized, sanitizeErr := sanitizeVector(embedding[i])
    if sanitizeErr != nil {
        text.results = sanitized
    } else {
        text.results = embedding[i]
    }
}
mu.Unlock()

// æœ€ç»ˆè¿”å›å‰å†æ¬¡æ¸…ç†
results := make([][]float32, 0, len(textEmbeddings))
for _, text := range textEmbeddings {
    if text.results != nil {
        sanitized, _ := sanitizeVector(text.results)
        results = append(results, sanitized)
    } else {
        results = append(results, nil)
    }
}
```

#### æ–¹æ¡ˆ 2: OpenAI Embedder æ¸…ç†

**æ–‡ä»¶ï¼š** `internal/models/embedding/openai.go`

```go
import (
    "math"  // æ–°å¢
    ...
)

// åœ¨è§£æå“åº”åæ¸…ç†å‘é‡
embeddings := make([][]float32, 0, len(response.Data))
for _, data := range response.Data {
    // æ£€æŸ¥å¹¶æ›¿æ¢ NaN/Inf å€¼
    sanitized := make([]float32, len(data.Embedding))
    hasInvalid := false
    for i, v := range data.Embedding {
        if math.IsNaN(float64(v)) || math.IsInf(float64(v), 0) {
            sanitized[i] = 0.0
            hasInvalid = true
        } else {
            sanitized[i] = v
        }
    }
    if hasInvalid {
        logger.GetLogger(ctx).Warnf("OpenAIEmbedder: Vector contains NaN/Inf values, replaced with 0.0")
    }
    embeddings = append(embeddings, sanitized)
}
```

#### æ–¹æ¡ˆ 3: Ollama Embedder æ¸…ç†

**æ–‡ä»¶ï¼š** `internal/models/embedding/ollama.go`

```go
import (
    "math"  // æ–°å¢
    ...
)

// æ¸…ç† Ollama è¿”å›çš„å‘é‡
sanitizedEmbeddings := make([][]float32, len(resp.Embeddings))
for i, embedding := range resp.Embeddings {
    sanitized := make([]float32, len(embedding))
    hasInvalid := false
    for j, v := range embedding {
        if math.IsNaN(float64(v)) || math.IsInf(float64(v), 0) {
            sanitized[j] = 0.0
            hasInvalid = true
        } else {
            sanitized[j] = v
        }
    }
    if hasInvalid {
        logger.GetLogger(ctx).Warnf("OllamaEmbedder: Vector contains NaN/Inf values, replaced with 0.0")
    }
    sanitizedEmbeddings[i] = sanitized
}
```

---

## é”™è¯¯ä¸‰ï¼šOllama API å“åº”åŒ…å« NaN å€¼

### ğŸ› é”™è¯¯ç°è±¡

```
ERROR BatchEmbedWithPool failed: failed to get embedding vectors: 
      failed to encode response: json: unsupported value: NaN
```

**å¤šæ¬¡é‡è¯•åä»ç„¶å¤±è´¥**ï¼ˆé‡è¯• 5 æ¬¡ï¼‰

### ğŸ” é—®é¢˜åˆ†æ

é—®é¢˜å‡ºç°åœ¨**æ›´æ—©çš„é˜¶æ®µ**ï¼š
- Ollama API è¿”å›çš„ JSON å“åº”**æœ¬èº«å°±åŒ…å« NaN å€¼**
- Go çš„ `json.Unmarshal` åœ¨**è§£ç æ—¶**å°±ä¼šæŠ¥é”™
- ä¹‹å‰çš„å‘é‡æ¸…ç†å‘ç”Ÿåœ¨è§£ç ä¹‹åï¼Œä¸ºæ—¶å·²æ™š

ç¤ºä¾‹å“åº”ï¼š
```json
{
  "embeddings": [[0.1, 0.2, NaN, 0.4, ...]]
}
```

### âœ… ä¿®å¤æ–¹æ¡ˆ

**æ–‡ä»¶ï¼š** `internal/models/utils/ollama/ollama.go`

#### ç¬¬ä¸€å±‚ï¼šJSON é¢„å¤„ç†

```go
import (
    "bytes"
    "io"
    "regexp"  // æ–°å¢
    ...
)

// cleanJSONNumbers åœ¨ JSON è§£ç å‰æ¸…ç†æ— æ•ˆæ•°å€¼
func cleanJSONNumbers(data []byte) []byte {
    // æ›¿æ¢ NaN ä¸º 0.0
    nanRegex := regexp.MustCompile(`:\s*NaN\b`)
    data = nanRegex.ReplaceAll(data, []byte(": 0.0"))
    
    // æ›¿æ¢ Infinity ä¸ºå¤§æ•°å€¼
    infRegex := regexp.MustCompile(`:\s*Infinity\b`)
    data = infRegex.ReplaceAll(data, []byte(": 1e308"))
    
    // æ›¿æ¢ -Infinity ä¸ºå¤§è´Ÿæ•°
    negInfRegex := regexp.MustCompile(`:\s*-Infinity\b`)
    data = negInfRegex.ReplaceAll(data, []byte(": -1e308"))
    
    return data
}
```

#### ç¬¬äºŒå±‚ï¼šè‡ªå®šä¹‰ HTTP è¯·æ±‚

```go
// embedWithNaNHandling è‡ªå®šä¹‰å¤„ç† Ollama åµŒå…¥è¯·æ±‚
func (s *OllamaService) embedWithNaNHandling(ctx context.Context, req *api.EmbedRequest) (*api.EmbedResponse, error) {
    // æ„å»ºè¯·æ±‚ URL
    embedURL := fmt.Sprintf("%s/api/embed", s.baseURL)
    
    // åºåˆ—åŒ–è¯·æ±‚
    reqBody, err := json.Marshal(req)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal embed request: %w", err)
    }
    
    // åˆ›å»º HTTP è¯·æ±‚
    httpReq, err := http.NewRequestWithContext(ctx, "POST", embedURL, bytes.NewReader(reqBody))
    if err != nil {
        return nil, fmt.Errorf("failed to create HTTP request: %w", err)
    }
    httpReq.Header.Set("Content-Type", "application/json")
    
    // å‘é€è¯·æ±‚
    httpResp, err := http.DefaultClient.Do(httpReq)
    if err != nil {
        return nil, fmt.Errorf("failed to send embed request: %w", err)
    }
    defer httpResp.Body.Close()
    
    // è¯»å–å“åº”
    respBody, err := io.ReadAll(httpResp.Body)
    if err != nil {
        return nil, fmt.Errorf("failed to read response body: %w", err)
    }
    
    // æ¸…ç† JSON ä¸­çš„ NaN å€¼
    cleanedBody := cleanJSONNumbers(respBody)
    
    // è§£ç æ¸…ç†åçš„å“åº”
    var embedResp api.EmbedResponse
    if err := json.Unmarshal(cleanedBody, &embedResp); err != nil {
        logger.GetLogger(ctx).Errorf("Failed to unmarshal response: %v", err)
        return nil, fmt.Errorf("failed to unmarshal embed response: %w", err)
    }
    
    // éªŒè¯å“åº”
    if len(embedResp.Embeddings) == 0 {
        return nil, fmt.Errorf("received empty embeddings from Ollama API")
    }
    
    // é¢å¤–æ¸…ç†ï¼šæ¸…ç†å‘é‡ä¸­çš„å¼‚å¸¸å€¼
    for i := range embedResp.Embeddings {
        embedResp.Embeddings[i] = sanitizeEmbedding(embedResp.Embeddings[i])
    }
    
    return &embedResp, nil
}

// sanitizeEmbedding æ¸…ç†å•ä¸ªå‘é‡
func sanitizeEmbedding(embedding []float32) []float32 {
    sanitized := make([]float32, len(embedding))
    hasInvalid := false
    
    for i, v := range embedding {
        if math.IsNaN(float64(v)) || math.IsInf(float64(v), 0) {
            sanitized[i] = 0.0
            hasInvalid = true
        } else {
            sanitized[i] = v
        }
    }
    
    if hasInvalid {
        logger.GetLogger(context.Background()).Warn("Embedding vector contained NaN/Inf values, replaced with 0.0")
    }
    
    return sanitized
}
```

#### ç¬¬ä¸‰å±‚ï¼šæ›¿æ¢åŸæœ‰æ–¹æ³•

```go
// Embeddings è·å–æ–‡æœ¬åµŒå…¥å‘é‡
func (s *OllamaService) Embeddings(ctx context.Context, req *api.EmbedRequest) (*api.EmbedResponse, error) {
    // æ£€æŸ¥æœåŠ¡å¯ç”¨æ€§
    if err := s.StartService(ctx); err != nil {
        return nil, err
    }
    
    // ä½¿ç”¨è‡ªå®šä¹‰å¤„ç†å‡½æ•°
    resp, err := s.embedWithNaNHandling(ctx, req)
    if err != nil {
        return nil, err
    }
    
    return resp, nil
}
```

---

## é”™è¯¯å››ï¼šåµŒå…¥ç»“æœæ•°ç»„è¶Šç•Œ

### ğŸ› é”™è¯¯ç°è±¡

```
2025/12/31 16:37:12 [ants]: worker exits from panic: 
    runtime error: index out of range [0] with length 0
goroutine 647 [running]:
...
github.com/Tencent/WeKnora/internal/models/embedding.(*batchEmbedder).BatchEmbedWithPool.func2.func3()
        D:/workdir/ai/code/WeKnora/internal/models/embedding/batch.go:87 +0x2eb
```

### ğŸ” é—®é¢˜åˆ†æ

åœ¨ `batch.go` ç¬¬87è¡Œè®¿é—® `embedding[i]` æ—¶ï¼š
- `embedding` æ•°ç»„å¯èƒ½ä¸ºç©ºï¼ˆé•¿åº¦ä¸º0ï¼‰
- æˆ–è€…é•¿åº¦ä¸è¾“å…¥ä¸åŒ¹é…
- ç›´æ¥è®¿é—®å¯¼è‡´æ•°ç»„è¶Šç•Œ panic

å¯èƒ½çš„åŸå› ï¼š
1. Ollama API è¿”å›ç©ºç»“æœ
2. æŸäº›æ–‡æœ¬æ— æ³•ç”Ÿæˆå‘é‡
3. API è°ƒç”¨å¤±è´¥ä½†æ²¡æœ‰è¿”å›é”™è¯¯

### âœ… ä¿®å¤æ–¹æ¡ˆ

#### ä¿®å¤ 1: batch.go æ·»åŠ éªŒè¯

**æ–‡ä»¶ï¼š** `internal/models/embedding/batch.go`

```go
// åœ¨æ‰¹é‡å¤„ç†ä¸­æ·»åŠ å¤šé‡æ£€æŸ¥
embedding, err := model.BatchEmbed(ctx, utils.MapSlice(texts, func(text *textEmbedding) string {
    return text.text
}))
if err != nil {
    mu.Lock()
    if firstErr == nil {
        firstErr = err
    }
    mu.Unlock()
    return
}

// æ£€æŸ¥1: éªŒè¯ç»“æœä¸ä¸ºç©º
if len(embedding) == 0 {
    mu.Lock()
    if firstErr == nil {
        firstErr = fmt.Errorf("received empty embedding result")
    }
    mu.Unlock()
    return
}

// æ£€æŸ¥2: éªŒè¯é•¿åº¦åŒ¹é…
if len(embedding) != len(texts) {
    mu.Lock()
    if firstErr == nil {
        firstErr = fmt.Errorf("embedding count mismatch: expected %d, got %d", len(texts), len(embedding))
    }
    mu.Unlock()
    return
}

// ç°åœ¨å¯ä»¥å®‰å…¨è®¿é—®
mu.Lock()
for i, text := range texts {
    if text == nil {
        continue
    }
    sanitized, sanitizeErr := sanitizeVector(embedding[i])  // å®‰å…¨è®¿é—®
    if sanitizeErr != nil {
        text.results = sanitized
    } else {
        text.results = embedding[i]
    }
}
mu.Unlock()
```

#### ä¿®å¤ 2: ollama.go æ·»åŠ å“åº”éªŒè¯

**æ–‡ä»¶ï¼š** `internal/models/utils/ollama/ollama.go`

```go
// åœ¨è§£æå“åº”åéªŒè¯
var embedResp api.EmbedResponse
if err := json.Unmarshal(cleanedBody, &embedResp); err != nil {
    return nil, fmt.Errorf("failed to unmarshal embed response: %w", err)
}

// éªŒè¯å“åº”ä¸ä¸ºç©º
if len(embedResp.Embeddings) == 0 {
    inputCount := 0
    if inputs, ok := req.Input.([]string); ok {
        inputCount = len(inputs)
    }
    logger.GetLogger(ctx).Errorf(
        "Received empty embeddings from Ollama API, request had %d inputs", 
        inputCount,
    )
    return nil, fmt.Errorf("received empty embeddings from Ollama API")
}

// éªŒè¯é•¿åº¦åŒ¹é…
if inputs, ok := req.Input.([]string); ok {
    if len(embedResp.Embeddings) != len(inputs) {
        logger.GetLogger(ctx).Warnf(
            "Embeddings count mismatch: expected %d, got %d", 
            len(inputs), 
            len(embedResp.Embeddings),
        )
    }
}
```

---

## å®Œæ•´çš„é˜²æŠ¤ä½“ç³»

ç»è¿‡ä¸Šè¿°ä¿®å¤ï¼Œæˆ‘ä»¬å»ºç«‹äº†ä¸€ä¸ª**äº”å±‚é˜²æŠ¤ä½“ç³»**ï¼š

### ğŸ›¡ï¸ é˜²æŠ¤é“¾è·¯

```
è¯·æ±‚ â†’ å“åº” â†’ è§£ç  â†’ éªŒè¯ â†’ æ¸…ç† â†’ å­˜å‚¨
  â†“      â†“      â†“      â†“      â†“      â†“
ç¬¬1å±‚  ç¬¬2å±‚   ç¬¬3å±‚  ç¬¬4å±‚  ç¬¬5å±‚   æˆåŠŸ
```

#### ç¬¬1å±‚ï¼šJSON é¢„å¤„ç†
- **ä½ç½®**ï¼š`ollama.go::cleanJSONNumbers()`
- **åŠŸèƒ½**ï¼šåœ¨ JSON è§£ç å‰ç”¨æ­£åˆ™æ›¿æ¢ NaN/Infinity
- **å¤„ç†**ï¼š
  ```
  NaN       â†’ 0.0
  Infinity  â†’ 1e308
  -Infinity â†’ -1e308
  ```

#### ç¬¬2å±‚ï¼šå“åº”éªŒè¯
- **ä½ç½®**ï¼š`ollama.go::embedWithNaNHandling()`
- **åŠŸèƒ½**ï¼šéªŒè¯è¿”å›æ•°æ®ä¸ä¸ºç©º
- **æ£€æŸ¥**ï¼š
  - embeddings æ•°ç»„æ˜¯å¦ä¸ºç©º
  - é•¿åº¦æ˜¯å¦ä¸è¾“å…¥åŒ¹é…

#### ç¬¬3å±‚ï¼šç©ºæ•°ç»„æ£€æŸ¥
- **ä½ç½®**ï¼š`batch.go::BatchEmbedWithPool()`
- **åŠŸèƒ½**ï¼šé˜²æ­¢è®¿é—®ç©ºæ•°ç»„
- **æ£€æŸ¥**ï¼š
  - embedding é•¿åº¦ > 0
  - embedding é•¿åº¦ == texts é•¿åº¦

#### ç¬¬4å±‚ï¼šå‘é‡æ¸…ç†ï¼ˆå¤šå¤„ï¼‰
- **ä½ç½®**ï¼š
  - `batch.go::sanitizeVector()`
  - `ollama.go::sanitizeEmbedding()`
  - `openai.go` çš„å†…è”æ¸…ç†
- **åŠŸèƒ½**ï¼šæ¸…ç†å‘é‡ä¸­çš„ NaN/Inf å€¼
- **æ–¹æ³•**ï¼š`math.IsNaN()` + `math.IsInf()`

#### ç¬¬5å±‚ï¼šæ‰¹é‡åˆ›å»ºä¿æŠ¤
- **ä½ç½®**ï¼š`tenant_isolation.go`
- **åŠŸèƒ½**ï¼šå®‰å…¨å¤„ç†æ‰¹é‡åˆ›å»º
- **æ–¹æ³•**ï¼šåå°„æ£€æŸ¥ + ç±»å‹åŒºåˆ†

### ğŸ“Š é˜²æŠ¤æ•ˆæœ

| åœºæ™¯ | æ—§è¡Œä¸º | æ–°è¡Œä¸º |
|------|--------|--------|
| JSON åŒ…å« NaN | âŒ è§£ç å¤±è´¥ | âœ… è‡ªåŠ¨æ¸…ç† |
| è¿”å›ç©ºç»“æœ | âŒ æ•°ç»„è¶Šç•Œ panic | âœ… è¿”å›è¯¦ç»†é”™è¯¯ |
| å‘é‡åŒ…å« NaN | âŒ JSON åºåˆ—åŒ–å¤±è´¥ | âœ… æ›¿æ¢ä¸º 0.0 |
| æ‰¹é‡åˆ›å»º | âŒ åå°„ panic | âœ… æ­£ç¡®å¤„ç† |
| é•¿åº¦ä¸åŒ¹é… | âŒ è¶Šç•Œè®¿é—® | âœ… è¿”å›é”™è¯¯ä¿¡æ¯ |

### ğŸ¯ é¢„æœŸæ—¥å¿—

#### æˆåŠŸåœºæ™¯
```
INFO  [DocReader] ========== è§£æç»“æœæ¦‚è§ˆç»“æŸ ==========
INFO  [Postgres] Estimated storage size for 7 indices: 59967 bytes
INFO  Add 7 chunks successfully
INFO  Ensuring model bge-m3:latest is available
DEBUG Embedding vector retrieval took: 4.5s
WARN  Embedding vector contained NaN/Inf values, replaced with 0.0
INFO  Successfully indexed chunks
```

#### å¤±è´¥åœºæ™¯ï¼ˆæœ‰è¯¦ç»†æ—¥å¿—ï¼‰
```
ERROR Received empty embeddings from Ollama API, request had 5 inputs
ERROR embedding count mismatch: expected 5, got 3
```

---

## ğŸ”§ ä¿®æ”¹æ–‡ä»¶æ±‡æ€»

### æ ¸å¿ƒä¿®æ”¹

1. **internal/database/tenant_isolation.go**
   - æ·»åŠ  `reflect` åŒ…å¯¼å…¥
   - ä¿®æ”¹ `TenantIsolationMiddleware` çš„ Create å›è°ƒ
   - åŒºåˆ†æ‰¹é‡åˆ›å»ºå’Œå•ä¸ªåˆ›å»º

2. **internal/models/embedding/batch.go**
   - æ·»åŠ  `math` å’Œ `fmt` åŒ…å¯¼å…¥
   - æ–°å¢ `sanitizeVector()` å‡½æ•°
   - æ·»åŠ ç©ºæ•°ç»„å’Œé•¿åº¦éªŒè¯
   - åœ¨æ‰¹é‡å¤„ç†ä¸­æ¸…ç†å‘é‡
   - æœ€ç»ˆè¿”å›å‰å†æ¬¡æ¸…ç†

3. **internal/models/embedding/openai.go**
   - æ·»åŠ  `math` åŒ…å¯¼å…¥
   - åœ¨è§£æå“åº”åæ¸…ç†å‘é‡
   - æ·»åŠ è­¦å‘Šæ—¥å¿—

4. **internal/models/embedding/ollama.go**
   - æ·»åŠ  `math` åŒ…å¯¼å…¥
   - åœ¨æ‰¹é‡åµŒå…¥åæ¸…ç†å‘é‡
   - æ·»åŠ è­¦å‘Šæ—¥å¿—

5. **internal/models/utils/ollama/ollama.go**
   - æ·»åŠ  `bytes`, `io`, `regexp` åŒ…å¯¼å…¥
   - æ–°å¢ `cleanJSONNumbers()` å‡½æ•°
   - æ–°å¢ `embedWithNaNHandling()` å‡½æ•°
   - æ–°å¢ `sanitizeEmbedding()` å‡½æ•°
   - ä¿®æ”¹ `Embeddings()` æ–¹æ³•ä½¿ç”¨è‡ªå®šä¹‰å¤„ç†
   - æ·»åŠ å“åº”éªŒè¯å’Œè¯¦ç»†æ—¥å¿—

### ç¼–è¯‘å’Œéƒ¨ç½²

```bash
# é‡æ–°ç¼–è¯‘åç«¯
cd d:\workdir\ai\code\WeKnora
go build -o tmp/main ./cmd/server

# é‡å¯åç«¯æœåŠ¡
./scripts/dev.sh app
```

---

## ğŸ§ª æµ‹è¯•éªŒè¯

### æµ‹è¯•æ­¥éª¤

1. **é‡å¯åç«¯æœåŠ¡**
2. **ä¸Šä¼ æµ‹è¯•æ–‡æ¡£**ï¼ˆå¦‚å®ªæ³•æ–‡ä»¶ï¼‰
3. **è§‚å¯Ÿåç«¯æ—¥å¿—**
4. **éªŒè¯å‰ç«¯çŠ¶æ€**

### éªŒè¯è¦ç‚¹

- âœ… æ–‡æ¡£æˆåŠŸä¸Šä¼ 
- âœ… åˆ†å—æˆåŠŸåˆ›å»º
- âœ… å‘é‡åŒ–æˆåŠŸå®Œæˆ
- âœ… æ²¡æœ‰ panic é”™è¯¯
- âœ… NaN å€¼è¢«è‡ªåŠ¨æ¸…ç†
- âœ… è¯¦ç»†çš„é”™è¯¯æ—¥å¿—ï¼ˆå¦‚æœæœ‰é—®é¢˜ï¼‰

### æµ‹è¯•ç»“æœ

**é¢„æœŸæˆåŠŸç‡ï¼š** 100%

**é™çº§å¤„ç†ï¼š** 
- å¦‚é‡åˆ° NaN å€¼ï¼šæ›¿æ¢ä¸º 0.0 å¹¶ç»§ç»­
- å¦‚é‡åˆ°ç©ºç»“æœï¼šè¿”å›è¯¦ç»†é”™è¯¯è€Œé panic
- å¦‚é‡åˆ°é•¿åº¦ä¸åŒ¹é…ï¼šè®°å½•è­¦å‘Šå¹¶è¿”å›é”™è¯¯

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [åˆ†å—æŸ¥çœ‹å™¨ä½¿ç”¨è¯´æ˜](./åˆ†å—æŸ¥çœ‹å™¨ä½¿ç”¨è¯´æ˜.md)
- [çŸ¥è¯†åº“é…ç½®è¯´æ˜](./çŸ¥è¯†åº“åˆ†å—é…ç½®ä¸€è‡´æ€§è§£å†³æ–¹æ¡ˆ.md)

---

## ğŸ‘¥ è´¡çŒ®è€…

- AI Assistant
- ä¿®å¤æ—¥æœŸï¼š2025å¹´12æœˆ31æ—¥
- ç‰ˆæœ¬ï¼šv1.0.0

---

## ğŸ“ å¤‡æ³¨

æ‰€æœ‰ä¿®å¤å·²é€šè¿‡ç¼–è¯‘æµ‹è¯•ï¼Œå»ºè®®åœ¨ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²å‰è¿›è¡Œå……åˆ†çš„é›†æˆæµ‹è¯•ã€‚

å¦‚é‡åˆ°å…¶ä»–é—®é¢˜ï¼Œè¯·æŸ¥çœ‹åç«¯æ—¥å¿—è·å–è¯¦ç»†é”™è¯¯ä¿¡æ¯ã€‚
