# 问题生成确定性优化方案

## 问题背景

在知识库分块问题生成功能中，发现生成的问题存在不确定性问题：
- 有的问题包含年份："宪法修正案2018年修改了哪些内容？"
- 有的问题缺少年份："年宪法修正案新增了什么机构？"

这种不一致性会严重影响检索质量和用户体验。

## 根本原因

### 1. 元信息提取不完整
原实现只检测简单的日期模式（"年"+"月"），但文档元信息远不止日期：
- 作者/机构
- 文档类型
- 版本号
- 发布日期
- 关键标识

### 2. LLM输出不确定性
- Temperature设置为0.7，随机性较高
- Prompt约束力度不够（"应该"而非"必须"）
- 缺少正反示例

### 3. 上下文窗口限制
只提供相邻chunk的500字符上下文，距离远的chunk无法获取文档头部的元信息。

## 完整解决方案

### 方案一：智能元信息提取（已实现）

#### 1.1 使用LLM提取结构化元信息

```go
func (s *knowledgeService) extractDocumentMetadata(
    ctx context.Context, 
    chatModel chat.Chat, 
    chunks []types.Chunk, 
    docTitle string,
) string {
    // 收集前5个chunk（最多1500字符）
    var contentBuilder strings.Builder
    for i := 0; i < len(chunks) && i < 5; i++ {
        contentBuilder.WriteString(chunks[i].Content)
        contentBuilder.WriteString("\n")
        if contentBuilder.Len() > 1500 {
            break
        }
    }
    
    // 使用LLM提取元信息
    prompt := `请分析以下文档开头部分，提取关键的文档元信息：
1. 完整标题（包括括号中的年份、版本等）
2. 日期/时间（如"2018年3月11日"）
3. 作者或发布机构
4. 文档类型（如"法律"、"技术规范"、"学术论文"等）
5. 版本号或修订信息
6. 其他关键标识信息`
    
    // Temperature=0.1 确保稳定提取
    response, err := chatModel.Chat(ctx, messages, &chat.ChatOptions{
        Temperature: 0.1,
        MaxTokens:   256,
    })
    
    return strings.TrimSpace(response.Content)
}
```

#### 1.2 提取结果示例

对于文档 `中华人民共和国宪法修正案（2018年）.md`：

```
2018年3月11日 第十三届全国人民代表大会第一次会议通过
文档：中华人民共和国宪法修正案（2018年）
类型：法律文件
```

### 方案二：降低LLM随机性

#### 2.1 降低Temperature

```go
response, err := chatModel.Chat(ctx, []chat.Message{
    {Role: "user", Content: prompt},
}, &chat.ChatOptions{
    Temperature: 0.3,  // 从0.7降低到0.3
    MaxTokens:   512,
})
```

**效果**：显著提高输出稳定性，减少随机变化。

### 方案三：强化Prompt约束

#### 3.1 新Prompt结构

```
## 文档元信息（必须严格遵守）
[LLM提取的结构化元信息]
文档名称：{{.DocName}}

## 主要内容
{{.Content}}

## 强制性约束（必须100%遵守）
1. **如果文档元信息中包含日期、年份、版本号等关键标识，
   生成的每个问题都必须包含这些信息**
   - 例如：必须说"2018年宪法修正案"，不能只说"宪法修正案"
   
2. **问题中禁止使用任何代词或指代词**
   （如"它"、"这个"、"该"、"本"、"此"、"其"等）
   
3. **每个问题必须是完整独立的**，脱离上下文也能被理解

## 错误示例（禁止）
❌ "年宪法修正案修改了什么？" （缺少年份）
❌ "该文件规定了什么？" （使用代词）

## 正确示例（参考）
✓ "2018年宪法修正案修改了哪些内容？" （包含年份）
✓ "中华人民共和国宪法修正案（2018年）新增了什么机构？" （完整标识）
```

#### 3.2 关键改进点

1. **"必须"代替"应该"**：强制性约束
2. **100%遵守**：明确无例外
3. **正反示例**：帮助LLM理解正确格式
4. **元信息前置**：放在最显眼位置

### 方案四：调用流程优化

```go
// 1. 在处理前提取全局元信息
docMetadata := s.extractDocumentMetadata(ctx, chatModel, textChunks, knowledge.Title)

// 2. 为每个chunk生成问题时注入元信息
for i, chunk := range textChunks {
    questions, err := s.generateQuestionsWithContext(
        ctx, 
        chatModel, 
        chunk.Content,
        prevContent, 
        nextContent, 
        knowledge.Title,
        docMetadata,  // ← 全局元信息注入
        questionCount,
    )
}
```

## 预期效果

### 优化前
```
问题1: 年宪法修正案新增了什么机构？          ← 缺少年份
问题2: 宪法修正案2018年修改了哪些内容？     ← 有年份但格式不统一
问题3: 该修正案对民族关系做了什么修改？     ← 使用代词
```

### 优化后
```
问题1: 2018年宪法修正案新增了什么机构？
问题2: 2018年宪法修正案修改了哪些内容？
问题3: 2018年宪法修正案对民族关系描述做了哪些修改？
```

**特点**：
✅ 所有问题都包含"2018年"关键标识  
✅ 格式统一  
✅ 无代词  
✅ 完整独立  

## 适用场景

### 1. 法律文档
- 元信息：发布日期、会议名称、修订版本
- 示例："2018年3月11日 第十三届全国人民代表大会第一次会议通过"

### 2. 学术论文
- 元信息：作者、机构、期刊、发表日期
- 示例："张三、李四, 清华大学, IEEE 2023"

### 3. 技术文档
- 元信息：版本号、发布日期、组织
- 示例："API文档 v2.3.1, 2024年1月发布, OpenAI"

### 4. 企业文档
- 元信息：文档编号、发布部门、版本
- 示例："文档编号: DOC-2024-001, 人力资源部, 第3版"

## 技术细节

### 1. 元信息提取的鲁棒性

```go
// 处理提取失败的情况
if err != nil {
    logger.Warnf(ctx, "Failed to extract document metadata: %v", err)
    return ""  // 优雅降级，返回空字符串
}
```

即使元信息提取失败，问题生成仍可继续，只是缺少元信息注入。

### 2. Token消耗优化

- 元信息提取：每个文档仅调用1次LLM（MaxTokens=256）
- 问题生成：每个chunk调用1次LLM（MaxTokens=512）
- 总开销：n_chunks + 1 次LLM调用

### 3. Temperature选择

| 任务 | Temperature | 原因 |
|------|-------------|------|
| 元信息提取 | 0.1 | 需要高度确定性，避免幻觉 |
| 问题生成 | 0.3 | 平衡确定性和多样性 |

## 测试验证

### 测试文档
```
文档名称：中华人民共和国宪法修正案（2018年）.md
第一行：# 中华人民共和国宪法修正案（2018年）
第二行：2018年3月11日 第十三届全国人民代表大会第一次会议通过
```

### 测试步骤
1. 重新编译后端：`go build -o bin/weknora ./cmd/server`
2. 重启服务
3. 删除旧知识库，重新上传文档
4. 启用问题生成（questionCount=5）
5. 检查生成的问题

### 验证标准
✅ **所有问题都包含"2018年"或"2018年3月11日"**  
✅ 无代词（"它"、"该"、"本"等）  
✅ 格式统一  
✅ 问题独立完整  

## 部署说明

### 1. 代码修改
- 文件：`internal/application/service/knowledge.go`
- 修改点：
  1. 添加 `extractDocumentMetadata` 函数（47行）
  2. 修改 `generateQuestionsWithContext` 调用（1行）
  3. 修改 `defaultQuestionGenerationPrompt`（40行）
  4. 降低temperature（0.7→0.3）

### 2. 重新编译

```bash
cd D:/workdir/ai/code/WeKnora
go build -o bin/weknora ./cmd/server
```

### 3. 重启服务

```bash
# 停止现有服务
./scripts/dev.sh stop

# 启动服务
./scripts/dev.sh start
```

### 4. 验证
上传测试文档，生成问题，检查元信息是否正确注入。

## 后续优化方向

### 1. 元信息缓存
将提取的元信息存储到数据库，避免重复提取：

```go
type Knowledge struct {
    // ...existing fields
    Metadata string `json:"metadata"` // 存储提取的元信息
}
```

### 2. 元信息验证
生成问题后，验证关键元信息是否出现：

```go
func validateQuestion(question, metadata string) bool {
    // 提取metadata中的关键标识（年份、版本等）
    // 验证question中是否包含
}
```

### 3. 自动重试机制
如果生成的问题不符合要求，自动重试：

```go
for retry := 0; retry < 3; retry++ {
    questions := generateQuestions()
    if validateQuestions(questions, metadata) {
        break
    }
}
```

## 总结

通过**智能元信息提取 + 降低随机性 + 强化约束**三管齐下，彻底解决了问题生成的不确定性问题，确保：

1. ✅ **所有问题都包含关键元信息**（年份、版本、作者等）
2. ✅ **格式统一、表达规范**（无代词、独立完整）
3. ✅ **高度确定性**（降低Temperature + 强制约束）
4. ✅ **适用多种文档类型**（法律、学术、技术、企业文档）

这是一个**系统性的解决方案**，而非简单的规则匹配或关键词提取。
