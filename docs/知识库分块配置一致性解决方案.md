# 知识库分块配置一致性解决方案

## 问题描述

WeKnora 系统中存在两处分块配置：
1. **config.yaml 全局配置**：`knowledge_base` 节点
2. **数据库知识库配置**：`knowledge_bases.chunking_config` JSON 字段

这导致以下问题：
- 修改 config.yaml 不影响已存在的知识库
- 新旧知识库配置不一致
- 用户难以理解配置优先级

---

## 解决方案：默认值回填机制

### 核心思路

```
config.yaml（全局默认）
       ↓
知识库创建/读取时
       ↓
自动填充空值字段
       ↓
数据库配置（实际使用）
```

### 实现细节

#### 1. 新增方法：`EnsureChunkingDefaults`

**文件**：`internal/types/knowledgebase.go`

```go
// EnsureChunkingDefaults 确保分块配置具备默认值
// 从 config.yaml 中读取全局默认配置，填充空值字段
func (kb *KnowledgeBase) EnsureChunkingDefaults(defaultConfig *ChunkingConfig) {
    if kb == nil {
        return
    }
    
    // 如果完全没有配置，使用默认配置
    if kb.ChunkingConfig.ChunkSize == 0 && 
       kb.ChunkingConfig.ChunkOverlap == 0 && 
       len(kb.ChunkingConfig.Separators) == 0 {
        if defaultConfig != nil {
            kb.ChunkingConfig = *defaultConfig
        }
        return
    }
    
    // 部分配置为空时，使用默认值填充
    if defaultConfig != nil {
        if kb.ChunkingConfig.ChunkSize == 0 {
            kb.ChunkingConfig.ChunkSize = defaultConfig.ChunkSize
        }
        if kb.ChunkingConfig.ChunkOverlap == 0 {
            kb.ChunkingConfig.ChunkOverlap = defaultConfig.ChunkOverlap
        }
        if len(kb.ChunkingConfig.Separators) == 0 {
            kb.ChunkingConfig.Separators = defaultConfig.Separators
        }
    }
}
```

**功能**：
- 完全为空时：使用全局默认配置
- 部分为空时：只填充空值字段
- 已有值时：保持不变

---

#### 2. 修改服务层：添加 config 依赖

**文件**：`internal/application/service/knowledgebase.go`

**结构体修改**：
```go
type knowledgeBaseService struct {
    config         *config.Config  // 新增
    repo           interfaces.KnowledgeBaseRepository
    // ... 其他字段
}

func NewKnowledgeBaseService(
    config *config.Config,  // 新增参数
    repo interfaces.KnowledgeBaseRepository,
    // ... 其他参数
) interfaces.KnowledgeBaseService {
    return &knowledgeBaseService{
        config: config,  // 新增
        // ...
    }
}
```

**创建知识库时填充默认值**：
```go
func (s *knowledgeBaseService) CreateKnowledgeBase(ctx context.Context, kb *types.KnowledgeBase) (*types.KnowledgeBase, error) {
    // ... 原有逻辑
    kb.EnsureDefaults()
    
    // 新增：填充分块配置默认值
    defaultChunkingConfig := &types.ChunkingConfig{
        ChunkSize:    s.config.KnowledgeBase.ChunkSize,
        ChunkOverlap: s.config.KnowledgeBase.ChunkOverlap,
        Separators:   s.config.KnowledgeBase.SplitMarkers,
    }
    kb.EnsureChunkingDefaults(defaultChunkingConfig)
    
    // ... 保存到数据库
}
```

**读取知识库时也填充**：
```go
func (s *knowledgeBaseService) GetKnowledgeBaseByID(ctx context.Context, id string) (*types.KnowledgeBase, error) {
    kb, err := s.repo.GetKnowledgeBaseByID(ctx, id)
    if err != nil {
        return nil, err
    }
    
    kb.EnsureDefaults()
    
    // 新增：填充分块配置默认值
    defaultChunkingConfig := &types.ChunkingConfig{
        ChunkSize:    s.config.KnowledgeBase.ChunkSize,
        ChunkOverlap: s.config.KnowledgeBase.ChunkOverlap,
        Separators:   s.config.KnowledgeBase.SplitMarkers,
    }
    kb.EnsureChunkingDefaults(defaultChunkingConfig)
    
    return kb, nil
}
```

---

## 配置优先级

### 明确的优先级规则

| 场景 | ChunkSize | ChunkOverlap | Separators | 优先级 |
|------|-----------|--------------|------------|--------|
| **创建时**：前端未提供 | 0 | 0 | [] | 使用 config.yaml |
| **创建时**：前端部分提供 | 1000 | 0 | [] | 1000（前端） / 其他用默认 |
| **创建时**：前端全部提供 | 1000 | 200 | [...] | 全部使用前端配置 |
| **读取时**：数据库为空 | 0 | 0 | [] | 自动填充 config.yaml |
| **读取时**：数据库有值 | 512 | 50 | [...] | 保持数据库配置 |
| **修改时**：清空某字段 | 0 | 200 | [...] | 清空字段自动填充默认值 |

---

## 使用场景

### 场景 1：统一更新默认配置

**需求**：优化全局分块配置

**操作**：
1. 修改 config.yaml：
   ```yaml
   knowledge_base:
     chunk_size: 1000      # 原 512
     chunk_overlap: 200    # 原 50
     split_markers:        # 新增法律专用分隔符
       - "\n\n\n"
       - "\n\n"
       - "。\n"
       - "\n第"
       # ...
   ```

2. 重启服务

3. **新建知识库**：自动使用新配置
4. **已有知识库**：
   - 前端未自定义配置的字段：自动使用新配置
   - 前端已自定义的字段：保持不变

---

### 场景 2：创建使用默认配置的知识库

**前端请求**：
```json
{
  "name": "法律知识库",
  "type": "document",
  "chunking_config": {}  // 空对象或不提供此字段
}
```

**实际保存到数据库**：
```json
{
  "name": "法律知识库",
  "type": "document",
  "chunking_config": {
    "chunk_size": 1000,
    "chunk_overlap": 200,
    "separators": ["\n\n\n", "\n\n", "。\n", ...]
  }
}
```

**说明**：自动从 config.yaml 填充默认值

---

### 场景 3：部分自定义配置

**前端请求**：
```json
{
  "name": "法律知识库",
  "chunking_config": {
    "chunk_size": 2000  // 只自定义分块大小
  }
}
```

**实际保存到数据库**：
```json
{
  "chunking_config": {
    "chunk_size": 2000,           // 使用前端配置
    "chunk_overlap": 200,         // 使用默认配置
    "separators": [...]           // 使用默认配置
  }
}
```

---

### 场景 4：历史数据兼容

**数据库中的旧知识库**：
```json
{
  "chunking_config": {
    "chunk_size": 512,
    "chunk_overlap": 50,
    "separators": ["\n\n", "\n", "。"]
  }
}
```

**读取时行为**：
- 保持原有配置不变
- 如果某字段为 0 或空，则填充默认值

---

## 前端配置指南

### 推荐做法

#### 1. 使用全局默认（推荐）

**界面**：分块配置留空

**代码**：
```javascript
const createKnowledgeBase = {
  name: "新知识库",
  type: "document",
  // 不提供 chunking_config，或提供空对象
  chunking_config: {}
}
```

**优势**：
- 自动获得最优配置
- config.yaml 更新后自动生效
- 统一管理方便

---

#### 2. 部分自定义

**场景**：只想修改某一项

**代码**：
```javascript
const createKnowledgeBase = {
  name: "特殊知识库",
  chunking_config: {
    chunk_size: 2000  // 只自定义这一项
    // 其他字段留空，自动使用默认值
  }
}
```

---

#### 3. 完全自定义

**场景**：特殊需求知识库

**代码**：
```javascript
const createKnowledgeBase = {
  name: "特殊知识库",
  chunking_config: {
    chunk_size: 2000,
    chunk_overlap: 400,
    separators: ["\n\n", "\n"]  // 简化分隔符
  }
}
```

---

## 配置同步工具（未来扩展）

### 需求：批量更新历史知识库配置

**潜在实现**：

#### 1. API 端点
```
POST /api/v1/admin/knowledge-bases/sync-config
```

#### 2. 请求参数
```json
{
  "sync_mode": "empty_only",  // empty_only | force_update
  "fields": ["chunk_size", "chunk_overlap", "separators"]
}
```

#### 3. 同步模式
- `empty_only`：只更新为空的字段（安全）
- `force_update`：强制覆盖所有知识库配置（慎用）

#### 4. 响应
```json
{
  "success": true,
  "updated_count": 42,
  "skipped_count": 10,
  "details": [
    {
      "kb_id": "xxx",
      "kb_name": "法律知识库",
      "updated_fields": ["separators"],
      "status": "success"
    }
  ]
}
```

---

## 测试验证

### 测试用例

#### 1. 新建知识库 - 空配置
```bash
curl -X POST http://localhost:8080/api/v1/knowledge-bases \
  -H "Content-Type: application/json" \
  -d '{
    "name": "测试知识库",
    "type": "document"
  }'
```

**预期**：返回的 `chunking_config` 包含完整默认值

---

#### 2. 新建知识库 - 部分配置
```bash
curl -X POST http://localhost:8080/api/v1/knowledge-bases \
  -H "Content-Type: application/json" \
  -d '{
    "name": "测试知识库",
    "chunking_config": {
      "chunk_size": 2000
    }
  }'
```

**预期**：
- `chunk_size`: 2000（前端配置）
- `chunk_overlap`: 200（默认配置）
- `separators`: [...]（默认配置）

---

#### 3. 读取知识库 - 历史数据
```bash
curl http://localhost:8080/api/v1/knowledge-bases/{old_kb_id}
```

**预期**：如果数据库中某字段为空，返回时自动填充默认值

---

## FAQ

### Q1: 修改 config.yaml 后，已有知识库会生效吗？

**A**: 部分生效
- 数据库中为空的字段：会使用新的默认值
- 数据库中已有值的字段：保持原值不变

**建议**：如需全量更新，可使用配置同步工具（未来功能）

---

### Q2: 前端如何知道当前使用的是默认配置还是自定义配置？

**A**: 判断逻辑
```javascript
function isDefaultConfig(kb) {
  const defaultConfig = {
    chunk_size: 1000,
    chunk_overlap: 200,
    separators: [/* 从API获取 */]
  }
  
  return JSON.stringify(kb.chunking_config) === JSON.stringify(defaultConfig)
}
```

**UI 提示**：
```
分块配置: [使用全局默认] [自定义] 
```

---

### Q3: 如何查看当前的全局默认配置？

**A**: 两种方式

1. **查看配置文件**：`config/config.yaml`

2. **API 查询**（未来扩展）：
   ```
   GET /api/v1/admin/config/defaults
   ```
   
   返回：
   ```json
   {
     "knowledge_base": {
       "chunk_size": 1000,
       "chunk_overlap": 200,
       "split_markers": [...]
     }
   }
   ```

---

### Q4: 能否为不同类型的知识库设置不同的默认配置？

**A**: 可扩展实现

**config.yaml 扩展**：
```yaml
knowledge_base:
  document:  # 文档类知识库
    chunk_size: 1000
    chunk_overlap: 200
    split_markers: [...]
    
  faq:  # FAQ 知识库
    chunk_size: 512
    chunk_overlap: 50
    split_markers: ["\n\n", "\n"]
```

**代码修改**：
```go
func (kb *KnowledgeBase) EnsureChunkingDefaults(config *config.Config) {
    var defaultConfig *ChunkingConfig
    
    switch kb.Type {
    case KnowledgeBaseTypeDocument:
        defaultConfig = &ChunkingConfig{
            ChunkSize:    config.KnowledgeBase.Document.ChunkSize,
            // ...
        }
    case KnowledgeBaseTypeFAQ:
        defaultConfig = &ChunkingConfig{
            ChunkSize:    config.KnowledgeBase.FAQ.ChunkSize,
            // ...
        }
    }
    
    // ... 填充逻辑
}
```

---

## 总结

### 解决方案优势

✅ **自动填充**：无需手动配置，自动使用最优默认值  
✅ **向下兼容**：不影响已有知识库  
✅ **灵活覆盖**：支持部分自定义  
✅ **统一管理**：修改 config.yaml 即可更新默认值  
✅ **简化前端**：前端无需关心复杂的默认值逻辑

### 最佳实践

1. **config.yaml**：定义最优默认配置（1000/200/法律专用分隔符）
2. **普通知识库**：创建时不提供 chunking_config，自动使用默认
3. **特殊知识库**：根据需求自定义特定字段
4. **配置优化**：定期评估并更新 config.yaml 默认值
5. **历史数据**：使用配置同步工具批量更新（未来功能）

---

## 附录：修改文件清单

| 文件 | 修改内容 | 说明 |
|------|---------|------|
| `internal/types/knowledgebase.go` | 新增 `EnsureChunkingDefaults` 方法 | 默认值填充逻辑 |
| `internal/application/service/knowledgebase.go` | 添加 config 字段和构造参数 | 访问全局配置 |
| `internal/application/service/knowledgebase.go` | `CreateKnowledgeBase` 添加默认值填充 | 创建时填充 |
| `internal/application/service/knowledgebase.go` | `GetKnowledgeBaseByID` 添加默认值填充 | 读取时填充 |
| `internal/application/service/knowledgebase.go` | `ListKnowledgeBases` 添加默认值填充 | 列表读取时填充 |
| `config/config.yaml` | 优化分块默认配置 | 1000/200/法律专用分隔符 |

---

**最后更新**：2025-12-31  
**版本**：v1.0
